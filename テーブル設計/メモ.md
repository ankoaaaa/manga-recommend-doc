# 漫画推薦サービス データベース論理設計

## 1. 目的

本サービスで収集・管理するデータの論理的な構造を定義する。目的は以下の通り。
1.  **推薦精度の自動向上:** ユーザーの入力とフィードバックの相関関係を分析し、AIへの指示（プロンプト）を自動で最適化する。
2.  **将来の新機能のためのデータ基盤:** ユーザーの行動や好みを蓄積し、サジェスト機能やパーソナライズ機能を実現するための土台とする。
3.  **ユーザーエンゲージメントの向上:** ユーザーがお気に入りの漫画を記録・管理できる「本棚」機能を提供する。

## 2. 論理エンティティと属性

### 2.1. USERS (ユーザー)
* SNS連携によるユーザー情報を管理する。
* **実装優先度:** 中（DB構築後）

| 論理名 | 物理名 (例) | データ型 | 説明 |
| :--- | :--- | :--- | :--- |
| ユーザーID | `id` | `bigint` | 主キー |
| 認証プロバイダ | `provider` | `varchar` | 認証方法 (例: "google", "twitter") |
| プロバイダID | `provider_id` | `varchar` | 各SNSでの一意なID |
| ユーザー名 | `username` | `varchar` | 表示名 |
| 作成日時 | `created_at` | `timestamp` | |

### 2.2. SESSIONS (推薦セッション)
* ユーザーがサイトを訪れてからの一連の対話（検索〜深掘り）をグループ化する。

| 論理名 | 物理名 (例) | データ型 | 説明 |
| :--- | :--- | :--- | :--- |
| セッションID | `id` | `bigint` | 主キー |
| ユーザーID | `user_id` | `bigint` | `USERS.id`への外部キー (ログイン時) |
| ユーザーの年代 | `user_age` | `varchar` | ゲスト利用時のユーザー属性 |
| ユーザーの性別 | `user_gender` | `varchar` | ゲスト利用時のユーザー属性 |
| 作成日時 | `created_at` | `timestamp` | セッション開始日時 |

### 2.3. REQUESTS (推薦リクエスト)
* 1回ごとの検索リクエスト（初回・深掘り）の内容を記録する。

| 論理名 | 物理名 (例) | データ型 | 説明 |
| :--- | :--- | :--- | :--- |
| リクエストID | `id` | `bigint` | 主キー |
| セッションID | `session_id` | `bigint` | `SESSIONS.id`への外部キー |
| 入力された漫画 | `input_titles` | `text` | ユーザーが入力した好きな漫画のリスト |
| 好きな理由 | `input_reason` | `text` | ユーザーが入力した自由記述 |
| 使用したフィルター | `filters_used` | `text` | 検索時に使用したフィルター条件 (JSON形式) |
| 生成された共感コメント | `generated_introduction` | `text` | AIが生成した導入文 |
| 作成日時 | `created_at` | `timestamp` | |

### 2.4. RESULTS (推薦結果)
* AIが提案した個々の漫画と、それに対するユーザーのフィードバックを記録する。

| 論理名 | 物理名 (例) | データ型 | 説明 |
| :--- | :--- | :--- | :--- |
| 結果ID | `id` | `bigint` | 主キー |
| リクエストID | `request_id` | `bigint` | `REQUESTS.id`への外部キー |
| 提案されたカテゴリ名 | `category_title` | `varchar` | AIが提案したカテゴリのタイトル |
| 提案された漫画 | `manga_title` | `varchar` | AIが提案した漫画のタイトル |
| フィードバック | `feedback` | `varchar` | ユーザー評価 ('good', 'bad', null) |
| 深掘りの起点フラグ | `is_deep_dive_trigger` | `boolean` | この結果が深掘りのきっかけになったか |
| 作成日時 | `created_at` | `timestamp` | |

### 2.5. USER_FAVORITES (ユーザーのお気に入り)
* ユーザーが「本棚」に登録した漫画と、その満足度を管理する。
* **実装優先度:** 高（ユーザー登録機能と同時）

| 論理名 | 物理名 (例) | データ型 | 説明 |
| :--- | :--- | :--- | :--- |
| お気に入りID | `id` | `bigint` | 主キー |
| ユーザーID | `user_id` | `bigint` | `USERS.id`への外部キー |
| 漫画タイトル | `manga_title` | `varchar` | お気に入りに登録された漫画 |
| 満足度 | `satisfaction_rating`| `int` | ユーザーによる満足度評価 (例: 1-5) |
| 感想コメント | `comment` | `text` | ユーザーによる感想 |
| 作成日時 | `created_at` | `timestamp` | |

## 3. 実装計画

1.  **DB構築:** 上記の設計に基づき、データベースとテーブルを作成する。（PostgreSQLを推奨）
2.  **バックエンド実装:** Spring Data JPAを使い、各テーブルに対応するEntityクラスとRepositoryインターフェースを作成する。
3.  **機能実装:**
    * **DBへのデータ蓄積:** 現在のAPIロジックに、各テーブルへデータを保存する処理を追加する。
    * **ユーザー登録機能:** Spring Securityを導入し、SNS連携によるユーザー登録・ログイン機能を実装する。
    * **お気に入り機能:** `USER_FAVORITES`テーブルへのCRUD（作成・読み取り・更新・削除）を行うAPIを実装する。

計画通り、まずは**データベース周りの構築**、その次に**ユーザー登録機能**と進めていきましょう。